<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <title>Shell Sort - algoritimo de ordenação</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lora:ital,wght@0,400;0,700;1,400;1,700&family=Open+Sans+Condensed:ital,wght@0,300;1,300&family=Open+Sans:ital,wght@0,300;0,400;0,700;0,800;1,300;1,400;1,700;1,800&family=Oxygen+Mono&family=Poppins:ital,wght@0,300;0,700;1,300;1,700&display=swap">
        <link rel="stylesheet" href="assets/css/reset.css">
        <link rel="stylesheet" href="assets/css/highlight.css">
        <link rel="stylesheet" href="assets/css/style.css">
        <link rel="stylesheet" href="assets/css/color.css">
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script async src="https://static.codepen.io/assets/embed/ei.js"></script>
        <script src="assets/js/highlight.js"></script>
        <script src="assets/js/script.js"></script>
    </head>
    <body>
        <div class="container">
            <header>
                <a href="">abrir tudo</a>
                <a href="">fechar tudo</a>
            </header>
            <main>

<h1>Shell Sort - algoritimo de ordenação</h1>
<h2>Primeira ideia</h2>
<p>O shell sort trata-se de um refinamento do método de inserção que vimos em aula. Sua ideia é primeiro ordenar os elementos mais distantes uns dos outros e ir diminuindo o intervalo até que todos os elementos estejam adequadamente ordenados. Os intervalos sao diminuidos a partir da sequencia usada, que ira influenciar diretamente na complexidade do algoritmo.</p>
<blockquote class="warning">
<p>OBS</p>
<p>Neste handout vamos implementar a sequencia original do shell sort, a qual o intervalo é dividido por dois a cada iteracao. Lembre-se que a escolha da sequencia irá variar de acordo com as necessidades de aplicacao desse algoritmo.</p>
</blockquote>
<p>Abaixo tem uma lista das possíveis sequencias utilizadas nesse algoritmo:</p>
<ul>
<li>Sequencia original do shell sort - N/2 … N/4 … N/2^x</li>
<li>1, 4, 13, …, (3k – 1) / 2</li>
<li>1, 8, 23, 77, 281, 1073, 4193, 16577…4j+1+ 3·2j+ 1</li>
<li>1, 3, 7, 15, 31, 63, 127, 255, 511…</li>
<li>1, 3, 5, 9, 17, 33, 65,…</li>
<li>1, 2, 3, 4, 6, 9, 8, 12, 18, 27, 16, 24, 36, 54, 81…</li>
</ul>
<p>Em outras palavras, a ideia geral é a seguinte:</p>
<pre><code class="language-txt">intervalo = n/2
para cada intervalo em v:
    ordene os elementos separados pelo intervalo
</code></pre>
<p>Mas você nao falou que ele aplica o método de inserção? Cade o insertion sort nessa ideia?
Calma, o insertion sort é aplicado a cada comparacao entre dois elementos separados por um intervalo. Assim, podemos dizer que:</p>
<pre><code class="language-txt">intervalo = n/2
para cada intervalo em v:
    aplique o insertion sort entre os elementos separados pelo intervalo
</code></pre>
<p>Se você não se lembra muito bem como funciona o método de insercao, vale a pena fazer uma pequena revisao.</p>
<details class="answer">
<summary>Revisão: Insertion sort</summary>
<p>O insertion sort é um método de ordenação que funciona de maneira similar a como ordenamos cartas de baralho. Um índice percorre toda a lista e aloca os elementos em dois grupos: dos ordenados e dos não-ordenados.</p>
<p>Para selecionar quais elementos farão parte de cada uma das listas, comparamos o primeiro elemento do grupo dos não-ordenados com os elementos do grupo dos ordenados (que inicia-se com o primeiro elemento da lista). Caso o elemento sendo comparado seja menor do que o último elemento da lista dos ordenados, ele será comparado com o penúltimo elemento dos ordenados, e assim por diante. Até que ele é maior do que um deles ou a lista acaba e ele é encaixado ali, deslocando sempre o resto da lista para a direita conforme o elemento a ser alocado é deslocado para a esquerda.</p>
<p>Com isso, os elementos são ordenados e alocados automaticamente.</p>
<figure class="img"><img src="img/insertion-sort1.png" alt=""></figure>
</details>
<figure class="img"><img src="img/shell-sort1.png" alt=""></figure>
<p>A ideia é que o vetor seja percorrido a cada iteracao, e que a cada iteracao o valor do intervalo seja diminuido de acordo com a sequencia escolhida até que seja menor ou igual a 1. Como precisamos comparar dois elementos distantes h um do outro, podemos considerar que o elemento v[i] e v[i-h], sendo i inicialmente igual a h e j igual a Assim iremos percorrer o vetor ate que i seja igual a n-1, ou seja, quando chegamos ao final dele.</p>
<pre><code class="language-txt">intervalo = n/2
para cada intervalo maior que 0:
    para cada intervalo em v:
        aplique o insertion sort entre os elementos separados pelo intervalo
        intervalo/=2
</code></pre>
<blockquote class="question">
<p>Exercício</p>
<p>Tente simular o algoritmo para o vetor abaixo. Como esta o vetor ao final de cada iteracao do loop externo? E o tamanho do intervalo h?</p>
<pre><code class="language-txt">    v = {3 5 8 1} 
    n = 4
</code></pre>
<details class="answer">
<summary>Gabarito</summary>
<pre><code class="terminal nohighlight">fim da iteracao 1: v = {3 1 8 5}
                   h = 2

fim da iteracao 2: v = {1 3 5 8}
                   h = 1




</code></pre>
</details>
</blockquote>
<blockquote class="question">
<p>Exercício</p>
<p>Implemente o shell sort em C. Suponha que os elementos são inteiros.</p>
<details class="answer">
<summary>Gabarito</summary>
<pre><code class="language-c">void shellSort(int v[], int n) {
    for (int h = n / 2; h &gt; 0; h /= 2) {
        for (int i = h; i &lt; n; i += 1) {
            int temp = v[i];
            for (int j = i; j &gt;= h &amp;&amp; v[j - h] &gt; temp; j -= h) {
                v[j] = v[j - h];
            }
            v[j] = temp;
        }
    }
}
</code></pre>
</details>
</blockquote>
<h2>Estimando a complexidade do shell sort</h2>
<blockquote class="question">
<p>Exercício</p>
<p>Estime a complexidade do algoritmo.</p>
<blockquote class="warning">
<p>Aviso</p>
<p>Se precisar de ajuda, consulte o material da <a href="https://ensino.hashi.pro.br/desprog/aula/7/" target="_blank">aula 7</a>.</p>
</blockquote>
<details class="answer">
<summary>Gabarito</summary>
</details>
</blockquote>
<h2>Aplicações e recomendacoes do shell sort</h2>
<blockquote class="question">
<p>Exercício</p>
<p>Com base no que foi visto até agora, o que você consideraria vantagens desse algoritmo de ordenacao? e desvantagens?</p>
<details class="answer">
<summary>Gabarito</summary>
<p>Vantagens:</p>
<ul>
<li>codigo simples</li>
</ul>
<p>Desvantagens:</p>
<ul>
<li>A complexidade, bem como o tempo de execução irão variar de acordo com o vetor inicial. O shellsort sera mais eficiente naqueles casos em que o vetor ja esta pre oprdenado</li>
</ul>
</details>
</blockquote>
<p>O shell sort</p>
<h2>Referências</h2>
<ul>
<li>https://www.programiz.com/dsa/shell-sort</li>
</ul>


            </main>
            <footer>
                <a href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">
                    <img alt="CC BY-SA 4.0" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" title="Creative Commons Attribution-ShareAlike 4.0 International License"/>
                </a>
                © 2021 Marcelo Hashimoto
            </footer>
        </div>
    </body>
</html>
